1、所有hash结构的集合都会依赖于元素的hashCode值
理想情况下，希望不同的对象得到不同的hashCode值
现实中，可能出现不同的对象得到相同的hashCode值

结论/常规协定：
    （1）如果连个对象的hashCode值，不同，那么这两个对象一定不相等，所以就不用看equals方法
    hashCode值的比较要简单很多，因为是一个int值的比较，而equals比较相对复杂，可能比较很多属性值
    （2）如果两个对象调用equals相同，那么这两个对象hashCode一定要相同，否则就有问题，
    重写equals方法是，一定要重写hashCode方法，而且选择的属性也要一样
    （3）如果两个对象的hashCode值相同，那么这两个对象可能相同，也可能不同，
    所以需要再次调用equals方法作比较

2、hashCode在哈希表中怎么用？
    因为hashCode值是int类型，可以用它直接作为数组的[下标]。

如果数组足够大，那么就可以直接用hashCode值当下标，这是最快的。
但是数组首先不可能足够大，而且元素可能没有那么多，创建足够大的数组有点浪费。
那么实际中会用 hashCode值 听过某种公式 计算出一个合理的[下标]。

    （1）方案一：
    hashCode值 % 数组的长度 = 下标
    A:重复，是肯定的
    B:下标是否会越界，不会，[0,数组的长度)，[0,数组的长度-1]

    （2）方案二：(计算效率高)
        hashCode值 & (数组的长度-1) = 下标
        A:重复，是肯定的
        B:下标是否会越界，不会，[0,数组的长度)，[0,数组的长度-1]

    假设：数组的长度为16，数组的长度-1=15
    hashCode值   ????    ????    二进制
    数组的长度-1 0000    1111    二进制
    &---------------------------------
                00000   0000    0
                00000   0001    1
                00000   0010    2
                00000   0011    3
                00000   0100    4
                ....
                00000   1111    15

    数组的长度选择？ 讲究，数组的长度最好选择2的n次方
    假设：数组的长度为10，数组的长度-1=9
    hashCode值   ????    ????    二进制
    数组的长度-1 0000    1001    二进制
    &---------------------------------
                00000   0000    0
                00000   0001    1
                00000   1000    8
                00000   1001    9
                范围也是[0,9]但是只有4种可能，冲突的概率更高。

    （3）方案三：
    先对hashCode值做处理得到一个hash值，再用hash值 & (数组的长度-1)
     假设：数组的长度为16，数组的长度-1=15
     假设：数组的长度为16，数组的长度-1=15
         hashCode值   ????    ????    二进制
         数组的长度-1 0000    1111    二进制
         无论hashCode值的高危部分是什么值，都完全没有意义了，区分下标只能靠低几位的二进制值。
         这种情况会导致hash冲突大概率增加

        hashCode值处理 ???? xxxx   二进制
            数组的长度-1 0000 1111    二进制

        处理过的xxxx在JDK版本中。会包含原来hashCode值最高位的信息
        static final int hash(Object key) {
                int h;
                return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
        }
        hashCode是int类型，4个字节没，总共32位。
        h >>> 16，取高16位二进制
        (h= key ,hashCode()) ^ (h >>> 16)相当于
        用hashCode值的原二进制
        与
        高16位全是0 低16位是原来二进制的高16位值
        进行异或运算

        0111 1100 0011 1111 1100 0111 1010 0101 （1）
        0000 0000 0000 0000 0111 1100 0011 1111 （2）
        ^--------------------------------------
        0111 1100 0011 1111 1011 1011 1001 1010 （3）   和（1）不同

    结论：方案三可以保证两点
       （1）hash冲突概率降低，但是无法避免
       （2）数组的每一种下标都有可能
    由这两点，尽量让（key,value）均匀放到HashMap中，但是不能保证绝对均匀。
    而且不能保证按顺序存储，中间可能有空位。

3、如何解决hash冲突问题？
   （1）什么是hash冲突
   A:两个对象的hashCode值相同
   B:两个对象的hashCode值不同，但是经过计算 index 相同
   （2）如何解决？
   hash冲突意味着数组的某个位置需要存储多个元素。
   设计重新这个元素的类型，不能直接存储元素的值，
   而是要把元素用“结点”封装起来，这个结点可以是链表的结点，也可以是“树”的结点。
   JDK1.7：使用纯链表结点封装起来
   JDK1.8：既有链表结点又有树结点（而且还是红黑树结点）
        树的好处，就是提高了查询效率
   （3）JDK1.8为什么不干脆全部使用树结点呢，还有保留链表结点
   因为红黑树比较复杂，而且每次添加和删除的时候，都要调整，会使得效率降低，
   当链表的结点个数没有那么多的时候，使用链表反而更快

4、什么时候需要从链表变成树？
   （1）数组的长度 >=64
   （2）链表结点的个数 >8

5、如果数组的长度不够64，链表的结点个数达到8个怎么办？
   要先扩容数组，再处理。

   为什么是扩容解决呢？
   扩容有什么影响？ 数组的长度变大了。扩容为2倍

   假设：数组的长度为16，数组的长度-1=15
       hashCode值   ????    ????    二进制
       数组的长度-1 0000    1111    二进制

       数组的长度为32，数组的长度-1=31
       hashCode值   ???y    ????    二进制
       数组的长度-1 0001    1111    二进制

       如果y位置是0，扩容后没有影响。
       如果y位置是1，扩容后就有影响。

       下标会变，就会导致（key,value）换一个位置存储，原来链表有8个结点，可能换位置之后就没有8个了

6、问题：哈希表中的链表变为树之后，还会不会变回链表？
    会

7、什么时候会从树变回链表？
    （1）一直删除时，如果树的结点个数少于UNTREEIFY_THRESHOLD（6）个时，会考虑变会链表（称为反树化）。
    同时还要考虑：删除过程中发现
                当树的根结点的左或右结点为NULL时，就会考虑反树化。
                或者当树的根结点的左左结点为NULL时，也会考虑反树化。

    （2）添加操作引起了扩容，扩容过程中，因为移动位置导致树的结点个数少于6个，会考虑把树变为链表。


8、问题：除了树化的table.length没有达到64，但是结点的数量达到8了，导致数组扩容之外，
    有没有其他的条件会让数组扩容？
    会

9、什么时候扩容？
    （1）当map的元素个数size > threshold时，就会扩容
    扩容为原来的2倍。
    第一次：threshold（阈值）= DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY
    后面：threshold（阈值）= loadFactor（默认值是0.75）  * table.length（最开始是16） = 原来的threshold * 2;
    假设：table.length是64，threshold = 64*0.75=48

总结：数组的扩容有两种情况：
   （1）结点的数量达到8，但是table.length没有到达64，此时不看threshold，直接扩容
   （2）数组的本身元素个数达到threshold扩容




10、跟踪源码发现，HashMap的Entry实现类， 不管是JDK1.7的Entry类，还是JDK1.8类的Node类都会存储hash值。为什么要存储？
    因为我们每一次查询，添加、删除等操作。
    以查询为例：
        (key,vlaue)在不在map中
        用要查询的对象的hash值与原有(key,value)的key的hash值作比较，
        hash值相同的情况下，才会比较equals方法。
        如果hash不存起来，每一次比较的时候都要重新计算，这就会影响效率